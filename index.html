<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Mr-shen.GitHub.io by mr-shen</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Mr-shen.GitHub.io</h1>
      <h2 class="project-tagline">HELLO WROLD</h2>
    </section>

    <section class="main-content">
      <p>Swfit与Objective－C相比
＊从语法上来说，Swift更简单，更简洁
＊开发难度上，Swfit比OC难得多，开源框架比较少，会CocOaTouch开发上手简单，如果之间上手Swfit，遇到问题一查资料都是OC的例子
＊swift在arc的objc上架了类型导倒，泛型，运算符重载，没有异常捕捉  oc上也不怎么使用</p>

<p>Object-C有多继承吗？没有的话用什么代替？
没有，多继承在这里是用protocol 委托代理来实现的
cocoa 中所有的类都是NSObject 的子类，你不用去考虑繁琐的多继承 ,虚基类的概念.ood的多态特性 在 obj-c 中通过委托来实现.
2.1 Objective-C是面向对象的语言
Objective-C和Java C++一样，有封装，继承，多态，重用。但是它不像C++那样有重载操作法、模版和多继承，也没有Java的垃圾回收机制。
2.2 Objective-C的优点
Objective-C语言有C++ Java等面向对象的特点。Objective-C的优点是它是动态的。动态能力有三种：
动态类-运行时确定类的对象
动态绑定-运行时确定要调用的方法
动态加载--运行时为程序加载新的模块
动态类型（Dynamic typing）
运行时决定对象类型，id类型
id obj ＝ someInstance;
if ([obj isKindOfClass:someclass])
{
  someclass*classInstance = (someclass *)obj
}</p>

<p>动态绑定
动态绑定基于动态类型，某个实例对象类型被确定后，将某些属性和响应的方法绑定到实例上。该队相对应的属性和响应者消息也被完全确定。
在OC中最常用的是消息传递机制。调用实例的方法，所做的是向该实例对象的指针发送消息，实例在收到消息后，
从自身实现中寻找响应这条消息的方法。
在Cocoa层，我们一般向一个NSObject对象发送 －respondsToSelector活着instanceRespondToSelector，在消息机制被触发前
＋resolveClasssMethod  和＋resolveInstanceMethod将会被调用，此时有机会动态的响雷或者实例添加新方法</p>

<p>动态加载
在Retina设备上加载<a href="https://github.com/2x" class="user-mention">@2x</a>的图片</p>

<p>基本动态特性在常规的Cocoa开发中非常常用，由于Cocoac程序大量的使用Protocol－Delegate中的设计模式，因此大部分delegate指针类型必须是id
以满足运行时delegate的动态转换（Java里这种设计模式被称为Strategy？）
OC的动态性表现为三个方面：动态类型，动态绑定，动态加载。之所以叫动态，是因为必须到运行时（runtime ）才会做一些事</p>

<p>2.3 动态能力相关的isa指针
每 译的时候编译器就生成了，专门来描述某个类的定义)，这个类对象包含了Objective-C对象的一些信息（为了区分两个对象，我把前面提到的对象叫Objective-C对象），包括Objective-C对象的方法调度表，实现了什么协议等等。这个包含信息就是Objective-C动态能力的根源了。 </p>

<p>Object-C有私有方法吗？私有变量呢？
objective-c– 类里面的方法只有两种, 静态方法和实例方法. 这似乎就不是完整的面向对象了,按照OO的原则就是一个对象只暴露有用的东西. 如果没有了私有方法的话, 对于一些小范围的代码重用就不那么顺手了. 在类里面声名一个私有方法
<a href="https://github.com/interface" class="user-mention">@interface</a> Controller : NSObject { NSString *something; }</p>

<ul>
<li>(void)thisIsAStaticMethod;
– (void)thisIsAnInstanceMethod;
<a href="https://github.com/end" class="user-mention">@end</a>
<a href="https://github.com/interface" class="user-mention">@interface</a> Controller (private) -
(void)thisIsAPrivateMethod;
<a href="https://github.com/end" class="user-mention">@end</a>
</li>
</ul>

<p><a href="https://github.com/private" class="user-mention">@private</a>可以用来修饰私有变量
在Objective‐C中，所有实例变量默认都是私有的，所有实例方法默认都是公有的</p>

<p>关键字const什么含义</p>

<p>const意味着”只读”，下面的声明都是什么意思？
const int a;
int const a;
const int *a;
int * const a;
int const * a const;</p>

<p>前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。</p>

<p>结论：
•; 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果
你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清
理的。）
•; 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。
•; 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。</p>

<p>欲阻止一个变量被改变，可以使用 const 关键字。在定义该const 变量时，通常需要对它进行初
始化，因为以后就没有机会再去改变它了；
（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为 const，或二者同时指
定为const；
（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
（4）对于类的成员函数，若指定其为const 类型，则表明其是一个常函数，不能修改类的成员变量；
（5）对于类的成员函数，有时候必须指定其返回值为const 类型，以使得其返回值不为“左值”。</p>

<p>关键字volatile有什么含义？并给出三个不同例子？
一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到
这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：
• 并行设备的硬件寄存器（如：状态寄存器）
• 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
• 多线程应用中被几个任务共享的变量</p>

<p>• 一个参数既可以是const还可以是volatile吗？解释为什么。
• 一个指针可以是volatile 吗？解释为什么。</p>

<p>下面是答案：
• 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
• 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。</p>

      <footer class="site-footer">

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

